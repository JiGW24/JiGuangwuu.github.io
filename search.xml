<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[事务及隔离级别]]></title>
    <url>%2F2019%2F05%2F02%2F%E4%BA%8B%E5%8A%A1%E5%8F%8A%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%2F</url>
    <content type="text"><![CDATA[事务 简述事务是逻辑上的一组操作，要么都执行，要么都不执行。最简单的；例子如银行转账，双方一人账户增加多少钱，另一人账号就减少多少钱。 操作1. 开启事务： start transaction; 2. 回滚：rollback; 3. 提交：commit; 事务提交的方式： 1. 自动提交 MySQL的提交方式 2. 手动提交 Oracle的提交方式 修改事务提交的方式 查看事务的默认提交方式：SELECT @@autocommit; -- 1 代表自动提交 0 代表手动提交 修改默认提交方式： set @@autocommit = 0; 事务的四个特征 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败 持久性：当事务提交或回滚后，数据库会持久化的保存数据。 隔离性：多个事务之间。相互独立。 一致性：事务操作前后，数据总量不变 事务的隔离级别多个事务是相互隔离的、独立的，但多个事务处理同样一批数据时便会发生问题，这时就必须设置隔离级别来解决这些问题。 存在的问题 脏读(Dirty Read)：一个事务读取到另一个事务未提交的数据 不可重复读(虚读)(Unrepeatable Read)：同一个事务中，两次读取的数据不一样。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。 幻读(Phantom Read)：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。 有人也说还有第四种问题-丢失修改(Lost to modify)：指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=18，事务1的修改被丢失。 不可重复度和幻读区别：不可重复读的重点是修改，幻读的重点在于新增或者删除。 隔离级别 READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。 READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。 REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。 SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。 特点：安全等级越来越高，但效率越来越低。 数据库查询隔离级别： * select @@tx_isolation; 数据库设置隔离级别： * set global transaction isolation level 级别字符串; 补充在Github上的JavaGuide-master仓库中写到 由 SnailClimb 和 BugSpeak 共同完成。 这里需要注意的是：与 SQL 标准不同的地方在于InnoDB 存储引擎在 **REPEATABLE-READ（可重读）**事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ（可重读）** 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的**SERIALIZABLE(可串行化)**隔离级别。 因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是**READ-COMMITTED(读取提交内容):**，但是你要知道的是InnoDB 存储引擎默认使用 **REPEATABLE-READ（可重读）**并不会有任何性能损失。 InnoDB 存储引擎在 **分布式事务** 的情况下一般会用到**SERIALIZABLE(可串行化)**隔离级别。]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Oracle</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XML解析]]></title>
    <url>%2F2019%2F04%2F26%2FXML%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[解析 操作xml文档，将文档的数据读取到内存中。 解析方式DOM 将标记语言文档一次性加载进内存，在内存中形成一棵dom树 优点：操作方便，可以对文档进行CRUD的所有操作 缺点：占内存 SAX 逐行读取，基于事件驱动 优点：不占内存，相比DOM效率更高 缺点：只能读取，不能增删改 解析器常见解析器 1. JAXP：sun公司提供的解析器，支持dom和sax两种思想 2. DOM4J：一款非常优秀的解析器 3. Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 4. PULL：Android操作系统内置的解析器，sax方式的。 DOM4J本文中利用dom4j和xpath的支持进行解析，DOM4J中还提供了其他几种遍历节点的方法，例如枚举(Iterator)、递归、visitor模式等等。 范例 1. 导包 dom4j-1.6.1.jar jaxen-1.1-beta-6.jar 2. public class TestDemo01 { @Test public void method() throws DocumentException { //创建解析器 SAXReader saxReader = new SAXReader(); //解析xml Document document = saxReader.read(TestDemo01.class.getClassLoader().getResourceAsStream(&quot;student.xml&quot;)); //获取根标签 Element rootElement = document.getRootElement(); /*System.out.println(rootElement); //获取子标签 List elements = rootElement.elements(); //获取第一个 Object stu1 = elements.get(0); System.out.println(stu1); System.out.println(&quot;----------&quot;); //student个数 List student = rootElement.elements(&quot;student&quot;); int size = student.size(); System.out.println(size); System.out.println(&quot;----------&quot;); //获取第一个学号 Element stu = rootElement.element(&quot;student&quot;); String s1 = stu.attributeValue(&quot;number&quot;); System.out.println(s1); System.out.println(&quot;----------&quot;); //获取第一个年龄 Element age1 = stu.element(&quot;age&quot;); String text = age1.getText(); System.out.println(text); // 即每一级便签和下一级标签用element方法获取第一个 } } 3. 结合xpath Element element = (Element)rootElement.selectSingleNode(&quot;//student[@number=&apos;heima_0002&apos;]&quot;); System.out.println(element); //xpath语法可通过xpath API文档查询 可能出现的问题在idea中编程时，使用Schema约束会在写xml文件是自动出现 xmlns=”http://www.itcast.cn/xml&quot;，使用这样的xml编码方式再结合xpath进行解析时，会发生找不到结果的问题 &lt;students xmlns=&quot;http://www.itcast.cn/xml&quot;&gt; &lt;student number=&quot;heima_0001&quot;&gt; &lt;name&gt;zhangsan&lt;/name&gt; &lt;age&gt;24&lt;/age&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;/student&gt; &lt;/students&gt; 如获取 Element element = (Element)rootElement.selectSingleNode(&quot;//student[@number=&apos;heima_0002&apos;]&quot;); System.out.println(element); 结果为null Jsoup步骤： 1. 导入jar包 jsoup-1.11.2.jar JsoupXpath-0.3.2.jar 2. 获取Document对象 3. 获取对应的标签Element对象 4. 获取数据 代码： //2.1获取student.xml的path String path = JsoupDemo1.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath(); //2.2解析xml文档，加载文档进内存，获取dom树---&gt;Document Document document = Jsoup.parse(new File(path), &quot;utf-8&quot;); //3.获取元素对象 Element Elements elements = document.getElementsByTag(&quot;name&quot;); System.out.println(elements.size()); //3.1获取第一个name的Element对象 Element element = elements.get(0); //3.2获取数据 String name = element.text(); System.out.println(name); 对象的使用： 1. Jsoup：工具类，可以解析html或xml文档，返回Document * parse：解析html或xml文档，返回Document * parse​(File in, String charsetName)：解析xml或html文件的。 * parse​(String html)：解析xml或html字符串 * parse​(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象 2. Document：文档对象。代表内存中的dom树 * 获取Element对象 * getElementById​(String id)：根据id属性值获取唯一的element对象 * getElementsByTag​(String tagName)：根据标签名称获取元素对象集合 * getElementsByAttribute​(String key)：根据属性名称获取元素对象集合 * getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合 3. Elements：元素Element对象的集合。可以当做 ArrayList&lt;Element&gt;来使用 4. Element：元素对象 1. 获取子元素对象 * getElementById​(String id)：根据id属性值获取唯一的element对象 * getElementsByTag​(String tagName)：根据标签名称获取元素对象集合 * getElementsByAttribute​(String key)：根据属性名称获取元素对象集合 * getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合 2. 获取属性值 * String attr(String key)：根据属性名称获取属性值 3. 获取文本内容 * String text():获取文本内容 * String html():获取标签体的所有内容(包括字标签的字符串内容) 5. Node：节点对象 * 是Document和Element的父类 快捷查询方式： 1. selector:选择器 * 使用的方法：Elements select​(String cssQuery) * 语法：参考Selector类中定义的语法 2. XPath：XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言 * 使用Jsoup的Xpath需要额外导入jar包。 * 查询w3cshool参考手册，使用xpath的语法完成查询 * 代码： //1.获取student.xml的path String path = JsoupDemo6.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath(); //2.获取Document对象 Document document = Jsoup.parse(new File(path), &quot;utf-8&quot;); //3.根据document对象，创建JXDocument对象 JXDocument jxDocument = new JXDocument(document); //4.结合xpath语法查询 //4.1查询所有student标签 List&lt;JXNode&gt; jxNodes = jxDocument.selN(&quot;//student&quot;); for (JXNode jxNode : jxNodes) { System.out.println(jxNode); } System.out.println(&quot;--------------------&quot;); //4.2查询所有student标签下的name标签 List&lt;JXNode&gt; jxNodes2 = jxDocument.selN(&quot;//student/name&quot;); for (JXNode jxNode : jxNodes2) { System.out.println(jxNode); } System.out.println(&quot;--------------------&quot;); //4.3查询student标签下带有id属性的name标签 List&lt;JXNode&gt; jxNodes3 = jxDocument.selN(&quot;//student/name[@id]&quot;); for (JXNode jxNode : jxNodes3) { System.out.println(jxNode); } System.out.println(&quot;--------------------&quot;); //4.4查询student标签下带有id属性的name标签 并且id属性值为itcast List&lt;JXNode&gt; jxNodes4 = jxDocument.selN(&quot;//student/name[@id=&apos;itcast&apos;]&quot;); for (JXNode jxNode : jxNodes4) { System.out.println(jxNode); }]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>xml</tag>
        <tag>xpath</tag>
        <tag>DOM4J</tag>
        <tag>Jsoup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[更换电脑或重装系统时的博客配置]]></title>
    <url>%2F2019%2F03%2F30%2F%E5%8D%9A%E5%AE%A2%E9%87%8D%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[前言首先感谢网络上的大佬们，查阅了一些人的博客总算解决了这一难题。废话少说，下面是简单的教程。 准备 安装node.js 安装Git 备份你的本地博客目录的部分文件夹 node.js和Git的安装包参考 拷贝文件夹如下 _config.yml theme/ source/ scaffolds/ package.json .gitignore 配置你的Git桌面右键选择bash here,设置用户名称和邮件地址。 1 $ git config –global user.name “username” 2 $ git config –global user.email “username@xxxx.com“ 配置SSH Key输入 $ ssh-keygen -t rsa -C “你的邮件地址” 然后连续按三次回车，会生成id_rsa.pub文件，用记事本打开它，然后全部复制即可，待会要用。这个文件的地址：C:\Users\Administrator.ssh打开你的GitHub主页，打开设置-&gt;Deploy keys-&gt;Add deploy key.这里名称随便取，在下面粘贴内容保存即可。 我们回来测试下是否把SSH配置成功了。继续在bash里输入 $ ssh -T git@github.com 如果提示 Are you sure you want to continue connecting (yes/no)? ，输入yes，然后会看到 successfully authenticated,but github…..看到这个意味着已成功！ 正式工作接下来时hexo和一些组件的安装，恭喜了很快了。 安装hexo我们打开cmd命令行，输入 npm install -g hexo 这里可能会很慢，所以推荐使用淘宝镜像。 npm install -g cnpm –registry=https://registry.npm.taobao.org 验证是否安装成功使用： cnpm -v 安装了淘宝镜像后，都使用cnpm指令： cnpm install -g hexo // 安装 hexo 验证Hexo是否安装成功使用： hexo -v 安装一些组件 npm install hexo-deployer-git –save // 文章部署到 git 的模块（下面为选择安装） npm install hexo-generator-feed –save // 建立 RSS 订阅 npm install hexo-generator-sitemap –save // 建立站点地图 部署到Github输入指令 hexo generate hexo deploy 没有报错就OK了。这里讲讲hexo的一些快捷命令 hexo g == hexo generate hexo d == hexo deploy hexo s == hexo server hexo n == hexo new 测试尝试部署文章并使用以下指令更新部署 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 成功部署，恭喜你！博客重配置成功！ 如果觉得有用，不如给个Star Or Follow，感谢。]]></content>
      <categories>
        <category>HexoAndBlog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2019%2F03%2F26%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[理解设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 何为单例模式单例模式(Singleton)，又称单态模式或者单件模式。即保证一个类仅有一个实例，并提供一个访问它的全局访问点。目的是即控制特定的类只产生一个对象，也允许在一定情况下灵活的改变对象的个数。 如何实现先看一段代码 public class Thing { private Thing(){ } private static Thing instance = new Thing(); //这段代码保证了Thread safe public static Thing getInstance(){ return instance; ｝ ｝ 测试类 public class TestDemo { public static void main(String[] args) { Thing t1 = Thing.getInstance(); Thing t2 = Thing.getInstance(); System.out.println(t1); System.out.println(t2); } } 输出t1和t2的结果是一致的。可以发现，我们将构造方法私有化了，这使得外面的类无法通过引用来创建对象；同时为了保证类的可用性，就必须提供一个自己的对象以及访问这个对象的静态方法。因此，我们应该明白：单例模式只有一个角色，而客户通过调用类的方法来创建对象。 还有什么在上面的Thing类中我们“迫不及待”的创建了对象，但如果这个对象我们很长时间都没有使用就浪费了内存空间，因此称之为饿汉式。存在另一种写法，即懒汉式。看这段代码 private static Thing instance; public static Thing getInstance(){ if (instance==null){ instance = new Thing(); } return instance; } 很明显，当程序真正需要这个对象的时候我们才开始创建。但是这在多线程情况下是有问题的，为了防止多线程环境中产生多个实例，我们做出改进，使用同步处理。 private static Thing instance; public static Thing getInstance(){ //如果是对象还没创建的时候使用同步，如果对象已经创建完了，就不要同步了 ，这样效率就可以提高 if (instance==null){ synchronized (Thing.class){ if (instance==null){ //说明对象还没创建，所以里面使用了同步s instance = new Thing(); } } } return instance; } 这里我们使用的是同步代码块，为什么不要同步方法呢？ private static Thing instance; public synchronized static Thing getInstance(){ if (instance==null){ instance = new Thing(); } return instance; } 通过使用同步方法，迫使每个线程在进入这个方法前要等候别的进程离开该方法。但同步会降低性能，并且这里只有第一次执行该方法时才会正在需要同步。之后每一次调用这个方法，同步都是浪费的。 存在的问题在学习单例模式时，通过这方面的书籍了解到以下问题 如果觉得有用，不如给个Star Or Follow，感谢。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>interview</tag>
        <tag>designPattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于我的考研]]></title>
    <url>%2F2019%2F02%2F20%2F190405%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>mood</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何将本地项目部署到Github]]></title>
    <url>%2F2019%2F02%2F05%2F%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E5%88%B0github%2F</url>
    <content type="text"><![CDATA[前言众所周知，GitHub是一个面向开源及私有软件项目的托管平台，那我们该如何将本地项目导入到Github上呢，这里，我写一个简单的教程，希望对你有所帮助。 准备确定你的Git安装了，如果需要点击此处 开始首先在Github上新建一个repository，命名随意（以我为例，新建了一个Demo），勾选如图，create。 然后，进入你的repository,打开settings，可以看到Github Pages的设置，在source中选择master branch。 最后，选择完会刷新页面，在去看Gith Pages时，会有显示一个网址，这就是你之后访问你项目页面的网址。 快了在一个盘里右键点击git bash here，打开bash命令行。如图，输入命令在D盘创建了文件夹Demo，第三个命令是克隆地址，格式为 https://github.com/用户名/项目名.git 这时候你会发现你的D盘会多个Demo文件夹，打开它，进入根目录。 将自己的项目文件粘贴到这个根目录中。 执行如下命令， 这里面注意，第一次操作需要你输入相关账号和密码，到时根据提示输入即可 完成利用那个网址测试即可。 如果觉得有用，不如给个starorfollow，感谢。]]></content>
      <categories>
        <category>HexoAndBlog</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XML简介与约束]]></title>
    <url>%2F2018%2F12%2F22%2FXML%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[简介 XML是可扩展标记语言（Extensible Markup Language），可扩展即标签都是自定义的。 功能：存储数据 1. 配置文件 2. 在网络中传输 与HTML的区别 1. xml标签都是自定义的，html标签是预定义。 2. xml的语法严格（严格区分大小写），html语法松散 3. xml是存储数据的，html是展示数据 各个平台之间的数据传输类型，但现在已经被JSON替换了。XML可以存储简单、小量的数据。 基本语法 写法注意： 属性值必须使用引号(单双都可)引起来 标签名称区分大小写 示例 &lt;?xml version=&apos;1.0&apos; ?&gt; &lt;users&gt; &lt;user id=&apos;1&apos;&gt; &lt;name&gt;zhangsan&lt;/name&gt; &lt;age&gt;23&lt;/age&gt; &lt;gender&gt;男&lt;/gender&gt; &lt;/user&gt; &lt;user id=&apos;2&apos;&gt; &lt;name&gt;lisi&lt;/name&gt; &lt;age&gt;25&lt;/age&gt; &lt;gender&gt;男&lt;/gender&gt; &lt;/user&gt; &lt;/users&gt; 组成部分1. 文档声明 1. 格式：&lt;?xml 属性列表 ?&gt; 2. 属性列表： * version：版本号，必须的属性 * encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1 * standalone：是否独立 * 取值： * yes：不依赖其他文件 * no：依赖其他文件 2. 指令(了解)：结合css的 * &lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;a.css&quot; ?&gt; 3. 标签：标签名称自定义的 * 规则： * 名称可以包含字母、数字以及其他的字符 * 名称不能以数字或者标点符号开始 * 名称不能以字母 xml（或者 XML、Xml 等等）开始 * 名称不能包含空格 4. 属性： id属性值唯一 5. 文本： * CDATA区：在该区域中的数据会被原样展示 * 格式： &lt;![CDATA[ 数据 ]]&gt; 约束约束为规定XML文档的编写规则。 第一种约束 DTD 外部dtd：将约束的规则定义在外部的dtd文件中 * 本地：&lt;!DOCTYPE 根标签名 SYSTEM &quot;dtd文件的位置&quot;&gt; * 网络：&lt;!DOCTYPE 根标签名 PUBLIC &quot;dtd文件名字&quot; &quot;dtd文件的位置URL&quot;&gt; 内部dtd：写在内部 外部范例 //student.dtd文件 &lt;!ELEMENT students (student+) &gt; &lt;!ELEMENT student (name,age,sex)&gt; &lt;!ELEMENT name (#PCDATA)&gt; &lt;!ELEMENT age (#PCDATA)&gt; &lt;!ELEMENT sex (#PCDATA)&gt; &lt;!ATTLIST student number ID #REQUIRED&gt; //student.xml文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE students SYSTEM &quot;student.dtd&quot;&gt; &lt;students&gt; &lt;student number=&quot;s001&quot;&gt; &lt;name&gt;zhangsan&lt;/name&gt; &lt;age&gt;abc&lt;/age&gt; &lt;sex&gt;hehe&lt;/sex&gt; &lt;/student&gt; &lt;student number=&quot;s002&quot;&gt; &lt;name&gt;lisi&lt;/name&gt; &lt;age&gt;24&lt;/age&gt; &lt;sex&gt;female&lt;/sex&gt; &lt;/student&gt; &lt;/students&gt; 第二种约束 Schema 引入 1. 填写xml文档的根元素 2. 引入xsi前缀. xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 3. 引入xsd文件命名空间. xsi:schemaLocation=&quot;http://www.itcast.cn/xml student.xsd&quot; 4. 为每一个xsd约束声明一个前缀,作为标识 xmlns=&quot;http://www.itcast.cn/xml&quot; &lt;students xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://www.itcast.cn/xml&quot; xsi:schemaLocation=&quot;http://www.itcast.cn/xml student.xsd&quot;&gt; 范例 student.xsd &lt;?xml version=&quot;1.0&quot; ?&gt; &lt;xsd:schema xmlns=&quot;http://www.itcast.cn/xml&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; targetNamespace=&quot;http://www.itcast.cn/xml&quot; elementFormDefault=&quot;qualified&quot;&gt; &lt;xsd:element name=&quot;students&quot; type=&quot;studentsType&quot;/&gt; &lt;xsd:complexType name=&quot;studentsType&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element name=&quot;student&quot; type=&quot;studentType&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:complexType&gt; &lt;xsd:complexType name=&quot;studentType&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element name=&quot;name&quot; type=&quot;xsd:string&quot;/&gt; &lt;xsd:element name=&quot;age&quot; type=&quot;ageType&quot; /&gt; &lt;xsd:element name=&quot;sex&quot; type=&quot;sexType&quot; /&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;number&quot; type=&quot;numberType&quot; use=&quot;required&quot;/&gt; &lt;/xsd:complexType&gt; &lt;xsd:simpleType name=&quot;sexType&quot;&gt; &lt;xsd:restriction base=&quot;xsd:string&quot;&gt; &lt;xsd:enumeration value=&quot;male&quot;/&gt; &lt;xsd:enumeration value=&quot;female&quot;/&gt; &lt;/xsd:restriction&gt; &lt;/xsd:simpleType&gt; &lt;xsd:simpleType name=&quot;ageType&quot;&gt; &lt;xsd:restriction base=&quot;xsd:integer&quot;&gt; &lt;xsd:minInclusive value=&quot;0&quot;/&gt; &lt;xsd:maxInclusive value=&quot;256&quot;/&gt; &lt;/xsd:restriction&gt; &lt;/xsd:simpleType&gt; &lt;xsd:simpleType name=&quot;numberType&quot;&gt; &lt;xsd:restriction base=&quot;xsd:string&quot;&gt; &lt;xsd:pattern value=&quot;heima_\d{4}&quot;/&gt; &lt;/xsd:restriction&gt; &lt;/xsd:simpleType&gt; &lt;/xsd:schema&gt; student.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;students xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://www.itcast.cn/xml&quot; xsi:schemaLocation=&quot;http://www.itcast.cn/xml student.xsd&quot; &gt; &lt;student number=&quot;heima_0001&quot;&gt; &lt;name&gt;tom&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;/student&gt; &lt;/students&gt;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>xml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat问题和项目部署]]></title>
    <url>%2F2018%2F10%2F09%2Ftomcat%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Tomcat可能出现的问题 1. 黑窗口一闪而过： * 原因： 没有正确配置JAVA_HOME环境变量 * 解决方案：正确配置JAVA_HOME环境变量，并在path中添加%JAVA_HOME%\bin; 2. 启动报错： 1. 暴力修改：找到占用的端口号，并且找到对应的进程，杀死该进程 * 命令行输入netstat -ano，查询到端口豪对应进程的PID 2. 温柔修改：修改自身的端口号 * conf/server.xml * &lt;Connector port=&quot;8888&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8445&quot; /&gt; * 一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。 * 好处：在访问时，就不用输入端口号 在Tomcat中部署项目的方式 1. 直接将项目放到webapps目录下即可。 * /WebProject：项目的访问路径--&gt;虚拟目录 * 简化部署：将项目打成一个war包，再将war包放置到webapps目录下。 * war包会自动解压缩 2. 配置conf/server.xml文件 在&lt;Host&gt;标签体中配置 &lt;Context docBase=&quot;D:\WebProject&quot; path=&quot;/demo&quot; /&gt; * docBase:项目存放的路径 * path：虚拟目录 3. 在conf\Catalina\localhost创建任意名称的xml文件。在文件中编写 &lt;Context docBase=&quot;D:\WebProject&quot; /&gt; * 虚拟目录：xml文件的名称 4. 在IDE中]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse的maven插件安装]]></title>
    <url>%2F2018%2F09%2F07%2Feclipse%E6%8F%92%E4%BB%B6maven%2F</url>
    <content type="text"><![CDATA[以eclipse kepler为例，官网下载地址：http://www.eclipse.org/downloads/packages/release/Kepler/SR2 1.打开eclipse，help–install new software… 2.workwith里输入：http://download.eclipse.org/releases/kepler，输入完会有提示地址出现，点击回车静待... 3.在filter框中输入maven便能定位要安装的插件 4.选择“Collaboration”-“m2e - Maven Integration for Eclipse”，并点击next按钮进行安装 5.安装完成重启eclipse即可 6.配置你的maven 如果觉得有用，不如给个Star Or Follow，感谢。]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>eclipse</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多态的一道面试题]]></title>
    <url>%2F2018%2F08%2F11%2F%E5%A4%9A%E6%80%81%E7%9A%84%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[多态类A： class A { public String show(D obj){ return (&quot;A and D&quot;); } public String show(A obj){ return (&quot;A and A&quot;); } } 类B： class B extends A{ public String show(B obj){ return (&quot;B and B&quot;); } public String show(A obj){ return (&quot;B and A&quot;); } } 类C： class C extends B{} 类D： class D extends B{} 测试类： class DynamicTest{ public static void main(String[] args){ A a1 = new A(); A a2 = new B(); B b = new B(); C c = new C(); D d = new D(); System.out.println(a1.show(b)); System.out.println(a1.show(c)); System.out.println(a1.show(d)); System.out.println(a2.show(b)); System.out.println(a2.show(c)); System.out.println(a2.show(d)); System.out.println(b.show(b)); System.out.println(b.show(c)); System.out.println(b.show(d)); } } 答案： System.out.println(a1.show(b)); AA System.out.println(a1.show(c)); AA System.out.println(a1.show(d)); AD System.out.println(a2.show(b)); BA 编译看左边，看右边可有重写 System.out.println(a2.show(c)); BA 同样，看可有重写！ System.out.println(a2.show(d)); AD 编译看左边，但没有重写 System.out.println(b.show(b)); BB System.out.println(b.show(c)); BB 这里父类和爷爷类都可以，取最近的 System.out.println(b.show(d)); AD B是A的子类 ，会把A的方法都继承 如果觉得有用，不如给个Star Or Follow，感谢。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>interview</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构造、静态代码块面试题]]></title>
    <url>%2F2018%2F06%2F05%2F%E6%9E%84%E9%80%A0%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%2F</url>
    <content type="text"><![CDATA[复习构造代码块的执行时机：每次我们调用构造方法的时候都会先执行构造代码块中的代码，然后才去执行对应的构造方法中的代码。 静态代码块的执行时机：静态代码块其实就是在类加载的时候执行，一个类只会加载一次，所以静态代码块也最多只会执行一次。 public class Test01 { { System.out.println(&quot;Test01的构造代码块&quot;); } static { System.out.println(&quot;Test01的静态代码块&quot;); } public Test01() { System.out.println(&quot;Test01的构造方法&quot;); } public static void main(String[] args) { Student stu = new Student(); Student stu2 = new Student(); } } class Student { { System.out.println(&quot;Student的构造代码块&quot;); } static { System.out.println(&quot;Student的静态代码块&quot;); } public Student() { System.out.println(&quot;Student的构造方法&quot;); } } 答案：Test01的静态代码块 Student的静态代码块 Student的构造代码块Student的构造方法 Student的构造代码块 Student的构造方法 如果觉得有用，不如给个Star Or Follow，感谢。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>interview</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡、插入、选择排序]]></title>
    <url>%2F2018%2F03%2F03%2F%E6%8E%92%E5%BA%8F1%2F</url>
    <content type="text"><![CDATA[问题的引入从键盘输入10个整数并按从大到小的顺序排列，输出结果冒泡排序基本思想：比较所有相邻的两个元素，如果第一个数比第二个数大就交换它们两个。最后的数字应该最大得到升序排列。 package top.jgw; import java.util.Arrays; import java.util.Scanner; public class BubbleSort { public static void main(String[] args) { Scanner ra = new Scanner(System.in); System.out.print(&quot;请输入10个数：&quot;); int[] arr = new int[10]; for(int a=0;a&lt;10;a++){ arr[a] = ra.nextInt(); } System.out.println(&quot;排序前的arr：&quot;+Arrays.toString(arr)); for(int i=arr.length-1;i&gt;0;i--){ for(int j=1;j&lt;=i;j++){ if(arr[j-1]&gt;arr[j]){ int temp = arr[j-1]; arr[j-1] = arr[j]; arr[j] = temp; } } } System.out.println(&quot;排序后的arr ：&quot;+Arrays.toString(arr)); } } 结论：冒泡排序是一种稳定的排序方法。 若文件初状为正序，则一趟起泡就可完成排序，排序码的比较次数为n-1，且没有记录移动，时间复杂度是O(n) 若文件初态为逆序，则需要n-1趟起泡，每趟进行n-i次排序码的比较，且每次比较都移动三次，比较和移动次数均达到最大值∶O(n2) 起泡排序平均时间复杂度为O(n2) 插入排序基本思想：每一步将一个待排序的记录，按其顺序码大小插入到前面已经排序的序列的合适位置（从后向前找到合适位置后），直到全部插入排序完为止。 package top.jgw; import java.util.Arrays; import java.util.Scanner; public class InsertionSort { public static void main(String[] args){ int i,j; int temp=0; Scanner ra=new Scanner(System.in); System.out.print(&quot;请输入10个数：&quot;); int arr[]=new int[10]; for(int a=0;a&lt;10;a++){ arr[a]=ra.nextInt(); } System.out.println(&quot;排序前的arr: &quot;+Arrays.toString(arr)); for(i=1;i&lt;arr.length;i++){ temp=arr[i]; for(j=i-1;j&gt;=0 &amp;&amp; temp&lt;arr[j];j--){ arr[j+1]=arr[j]; } arr[j+1]=temp; } System.out.println(&quot;排序后的arr：&quot;+Arrays.toString(arr)); } } 结论：直接插入排序也是稳定的排序。文件初态不同时，直接插入排序所耗费的时间有很大差异。若文件初态为正序，则每个待插入的记录只需要比较一次就能够找到合适的位置插入，故算法的时间复杂度为O(n)，这时最好的情况。若初态为反序，则第i个待插入记录需要比较i+1次才能找到合适位置插入，故时间复杂度为O(n2)，这时最坏的情况。 选择排序基本思想：每一次排序都从待排序序列中选择一个最小元素放到已排好的序列的末端，重复此步骤可得到升序序列。 package top.jgw; import java.util.Arrays; import java.util.Scanner; public class SelectionSort { public static void main(String[] args){ Scanner ra=new Scanner(System.in); System.out.print(&quot;请输入10个数: &quot;); int arr[]=new int[10]; for(int a=0;a&lt;10;a++){ arr[a]=ra.nextInt(); } System.out.println(&quot;排序前的arr: &quot;+Arrays.toString(arr)); int temp=0; for(int i=0;i&lt;arr.length-1;i++){ for(int j=i+1;j&lt;arr.length;j++){ if(arr[i]&gt;arr[j]){ temp=arr[i]; arr[i]=arr[j]; arr[j]=temp; } } } System.out.println(&quot;排序后的arr: &quot;+Arrays.toString(arr)); } } 结论：简单选择排序是不稳定的排序，时间复杂度：T(n)=O(n2)。 日后补充… 如果觉得有用，不如给个Star Or Follow，感谢。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo＋next主题搭建GitHub blog干货教程]]></title>
    <url>%2F2018%2F01%2F10%2Fhexo%2F</url>
    <content type="text"><![CDATA[前言本人开始并非使用next主题，这个大家可以去hexo官网themes处挑选自己喜欢的。注意：点击主题预览图可以去预览下，点击主题名就可以去GitHub页面copy了。但个人觉得next主题更好，bug少，拓展性强。好了，废话少说，进入正题。 准备工作 注册github账号 安装node.js 链接：https://pan.baidu.com/s/1mji9SmO 密码：fjw1 安装git 链接：https://pan.baidu.com/s/1dGUlqEH 密码：q9ws我的电脑是Windows10，其他你根据我提供的百度云链接下载即可。安装git时全打勾。 创建仓库新建一个 你的用户名.github.io的仓库，比如说你的GitHub用户名是abc,那么你新建仓库名叫abc.github.io,你的博客搭建好之后访问的网站也就是 https://abc.github.io了。 那怎么删除仓库呢？？？打开settings 创建博客根目录在一个磁盘里创建一个文件夹，比如我，在D盘创建了一个blog文件夹。 正式工作配置SSH Key桌面右键打开git bash here,输入 $ cd ~/. ssh // 检查本机已存在的 ssh 密钥 再接着输入 ssh-keygen -t rsa -C “你的邮件地址” 然后连续按三次回车，会生成id_rsa.pub文件，用记事本打开它，然后全部复制即可，待会要用。这个文件的地址：C:\Users\Administrator.ssh打开你的GitHub主页，打开设置-&gt;Deploy keys-&gt;Add deploy key.这里名称随便取，在下面粘贴内容保存即可，有需要打勾就打勾。 我们回来测试下是否把SSH配置成功了。继续在bash里输入 $ ssh -T git@github.com 如果提示 Are you sure you want to continue connecting (yes/no)? ，输入yes，然后会看到 successfully authenticated,but github…..看到这个意味着已成功！ 配置信息 $ git config –global user.name “xxx”// 你的github用户名，比如上面的abc$ git config –global user.email “xxx@qq.com“// 填写你的github注册邮箱 使用hexo安装hexo我们打开cmd命令行，输入 npm install -g hexo 这里可能会很慢，所以推荐使用淘宝镜像。 安装：npm install -g cnpm --registry=https://registry.npm.taobao.org 验证是否安装成功使用：cnpm -v这里使用使用： cnpm install -g hexo安装hexo 验证Hexo是否安装成功使用：hexo -v 初始化hexo打开我们之前创建的文件夹，比如我的blog，右击鼠标，打开git bash here,输入 $ hexo init 我们的文件夹会自动下载一些文件到这个blog目录里。 继续输入 $ hexo g$ hexo s hexo s是指启动服务，成功打开后会有提示，登录localhost:4000即可看到初始页面，到这里你的blog就基本搭建好了。 新建文章在bash里输入 $ hexo new post “文章名” 然后去blog/source/_posts就可以看到 上传到GitHub配置_config.yml中的deploy部分，注意这里的_config.yml文件是blog根目录，并非themes里的同名文件。配置如下(xxx为你的GitHub名) deploy: type: git repository: git@github.com:xxx/xxx.github.io.git branch: master 再次注意：关于_config.yml文件的配置，冒号后一定要加个空格，否则就无法部署了。 一切完成后在bash中继续输入 npm install hexo-deployer-git –save #这里是安装插件，不然无法deploy 然后输入以下就可以了 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 成功后会提示：Deploy done：git 证明成功啦。这是打开你的xxx.github.io就可以看到网页啦！ 主题设置打开next使用文档有详细的教程。主题教程以及拓展： 绑定个性域名申请域名在阿里云或腾讯云申请域名。我是在阿里云申请的，实名认证很快，推荐。 解析域名按我的内容来即可。 部署域名在blog根目录的source文件夹中新建无后缀文件 CNAME。里面内容只写上你的域名即可，注意不需要www按之前的顺序deploy即可 如果觉得有用，不如给个Star Or Follow，感谢。]]></content>
      <categories>
        <category>HexoAndBlog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[出发永远是美好的一件事]]></title>
    <url>%2F2018%2F01%2F07%2F%E5%87%BA%E5%8F%91%2F</url>
    <content type="text"><![CDATA[去做就是啦。 总结了一七再去展望一八，哈哈我是真想做个技术流人才然后……忙着结束手头上的事情，项目等等，想着去全身心投入到学习中，这是促进我去搭建自己的独立博客的初衷，去学习，去整理，去分享。大学也浪了大半了，两次六级考试都几乎零准备，湖泊你说咋写来着？ 要说新年计划的话，最近打算好好总结Java的知识，以及对基本框架，数据结构与算法的学习，对博客的维护与优化，还有考研的准备！ 新年快乐！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>mood</tag>
      </tags>
  </entry>
</search>

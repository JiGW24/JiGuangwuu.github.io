<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring声明式事务全注解开发完成转账案例]]></title>
    <url>%2F2019%2F05%2F31%2FSpring%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%85%A8%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[xml配置文件在使用全注解形式去完成转账案例之前，我们先看看在使用纯xml配置的applicationConfiguration.xml &lt;bean id=&quot;accountDao&quot; class=&quot;com.xxx.dao.impl.AccountDaoImpl&quot;&gt; &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql:///account_db&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;accountService&quot; class=&quot;com.xxx.service.impl.AccountServiceImpl&quot;&gt; &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;/&gt; &lt;/bean&gt; &lt;!--配置平台事务管理器 同样要依赖dataSource--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!--通知事务的增强--&gt; &lt;!--propagation 事务传播行为 REQUIRED：指定当前方法必需在事务环境中运行，如果当前有事务环境就加入当前正在执行的事务环境， 如果当前没有事务，就新建一个事务。这是默认值。 isolation 事务隔离级别 DEFAULT：采用数据库默认隔离级别--&gt; &lt;tx:advice id=&quot;tx&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;transfer&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot;/&gt; &lt;tx:method name=&quot;find&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;*&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--事务的织入--&gt; &lt;aop:config proxy-target-class=&quot;true&quot;&gt; &lt;aop:advisor advice-ref=&quot;tx&quot; pointcut=&quot;execution(* com.xxxservice.impl.*.*(..))&quot;/&gt; &lt;/aop:config&gt; 全注解形式源码 建表 CREATE TABLE account( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20), money DECIMAL ); 导入所需坐标 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.32&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; AccountDaoImpl.java @Repository public class AccountDaoImpl implements AccountDao { @Autowired private JdbcTemplate jdbcTemplate; public void out(String outMan, double money) { jdbcTemplate.update(&quot;update account set money=money-? where name=?&quot;,money,outMan); } public void in(String inMan, double money) { jdbcTemplate.update(&quot;update account set money=money+? where name=?&quot;,money,inMan); } } AccountServiceImpl.java @Service @EnableTransactionManagement public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; @Transactional(isolation = Isolation.DEFAULT,propagation = Propagation.REQUIRED,readOnly = false) public void transfer(String outMan, String inMan, double money) { accountDao.out(outMan,money); // int i = 1/0; accountDao.in(inMan,money); } } SpringConfiguration.java @Configuration @ComponentScan(&quot;com.xxx&quot;) @Import(DataSourceConfiguration.class) public class SpringConfiguration { } DataSourceConfiguration.java @Configuration @PropertySource(&quot;classpath:jdbc.properties&quot;) public class DataSourceConfiguration { @Value(&quot;${jdbc.driver}&quot;) private String driverClass; @Value(&quot;${jdbc.url}&quot;) private String url; @Value(&quot;${jdbc.username}&quot;) private String user; @Value(&quot;${jdbc.password}&quot;) private String password; @Bean public DataSource getDataSource() throws PropertyVetoException { ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(driverClass); dataSource.setJdbcUrl(url); dataSource.setUser(user); dataSource.setPassword(password); return dataSource; } @Bean public JdbcTemplate getTemplate(DataSource dataSource){ return new JdbcTemplate(dataSource); } @Bean public DataSourceTransactionManager getDSTM(DataSource dataSource){ return new DataSourceTransactionManager(dataSource); } } jdbc.properties jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql:///account_db jdbc.username=root jdbc.password=123456 测试 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = SpringConfiguration.class) public class AnnoTest { @Autowired private AccountService accountService; @Test public void test02(){ accountService.transfer(&quot;tom&quot;,&quot;lucy&quot;,500f); } }]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>annotation</tag>
        <tag>transaction</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring注解]]></title>
    <url>%2F2019%2F05%2F29%2FSpring%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前言初学Spring,相较于xml文件的配置，注解开发的确要简洁的多。但有时还是会忘了一些，故在此整合。 一般注解列表注解 说明 @Component 使用在类上用于实例化Bean @Controller 使用在web层类上用于实例化Bean @Service 使用在service层类上用于实例化Bean @Repository 使用在dao层类上用于实例化Bean @Autowired 使用在字段上用于根据类型依赖注入 @Qualifier 结合@Autowired一起使用用于根据名称进行依赖注入 @Resource 相当于@Autowired+@Qualifier，按照名称进行注入 @Value 注入普通属性 @Scope 标注Bean的作用范围 @PostConstruct 使用在方法上标注该方法是Bean的初始化方法 @PreDestroy 使用在方法上标注该方法是Bean的销毁方法 配置组件扫描 &lt;!--注解的组件扫描--&gt; &lt;context:component-scan base-package=&quot;com.xxx&quot;&gt;&lt;/context:component-scan&gt; 较新的 @Configuration 用于指定当前类是一个 Spring 配置类，当创建容器时会从该类上加载注解 @ComponentScan 用于指定 Spring 在初始化容器时要扫描的包。 作用和在 Spring 的 xml 配置文件中 的 &lt;context:component-scan base-package=&quot;com.itheima&quot;/&gt;一样 @Bean 使用在方法上，标注将该方法的返回值存储到 Spring 容器中 @PropertySource 用于加载.properties 文件中的配置 @Import 用于导入其他配置类 这里注意非自定义的Bean的配置 加载properties文件的配置：context:property-placeholder 组件扫描的配置：context:component-scan Spring集成Junit测试注解 配置@Runwith、@ContextConfiguration注解这里测试的基本流程为 导入spring集成Junit的坐标 使用@Runwith注解替换原来的运行期 使用@ContextConfiguration指定配置文件或配置类 使用@Autowired注入需要测试的对象 创建测试方法进行测试 Demo @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = {SpringConfiguration.class}) public class SpringJunitTest { @Autowired private UserService userService; @Test public void testUserService(){ userService.save(); } } 基于AOP开发的注解先了解开发步骤 ①使用@Aspect标注切面类 ②使用@通知注解标注通知方法 ③在配置文件中配置aop自动代理aop:aspectj-autoproxy/ 其中第②步的注解有以下 声明式事务控制的注解开发@Transactional 在想要添加事务的方法上使用(可加参数) @EableTransactionManagement 注解驱动(相当于annotation-driven,一般放在业务层上) @EableAspectJAutoProxy 开启AOP自动代理支持]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>annotation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring通过DataSource获取数据库数据(非注解方式和注解形式)及Spring集成Junit测试]]></title>
    <url>%2F2019%2F05%2F27%2FSpring%E9%80%9A%E8%BF%87DataSource%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[非注解这里就不多说了，直接来源码 1.导入各坐标这里包括数据库连接池(druid/c3p0)，单元测试，数据库连接驱动坐标以及spring的依赖就不一一写出了 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--druid连接池--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.13&lt;/version&gt; &lt;/dependency&gt; 2.AccountDaoImpl.java public class AccountDaoImpl implements AccountDao { private JdbcTemplate template; public void setTemplate(JdbcTemplate template) { this.template = template; } public void findAll(){ List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(&quot;select * from teacher&quot;); for (Map&lt;String, Object&gt; map : list) { for (String s : map.keySet()) { System.out.println(s+&quot;:&quot;+map.get(s)); } } } } 3.AccountServiceImpl.java public class AccountServiceImpl implements AccountService { private AccountDaoImpl accountDao; public void setAccountDao(AccountDaoImpl accountDao) { this.accountDao = accountDao; } @Override public void findAll() { ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); AccountDao accountDao = (AccountDao) applicationContext.getBean(&quot;accountDao&quot;); accountDao.findAll(); System.out.println(&quot;username:&quot;+username); } } 4.applicationContext.xml &lt;bean id=&quot;accountDao&quot; class=&quot;top.jigw.dao.impl.AccountDaoImpl&quot;&gt; &lt;property name=&quot;template&quot; ref=&quot;jdbcTemplate&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;accountService&quot; class=&quot;top.jigw.service.impl.AccountServiceImpl&quot;&gt; &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSourceFactory&quot; factory-method=&quot;createDataSource&quot;&gt; &lt;constructor-arg name=&quot;properties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;driverClassName&quot;&gt;com.mysql.jdbc.Driver&lt;/prop&gt; &lt;prop key=&quot;url&quot;&gt;jdbc:mysql:///test&lt;/prop&gt; &lt;prop key=&quot;username&quot;&gt;root&lt;/prop&gt; &lt;prop key=&quot;password&quot;&gt;123456&lt;/prop&gt; &lt;/props&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;constructor-arg name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 5.单元测试 public class test { @Test public void test01() { ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); AccountService accountService = (AccountService) applicationContext.getBean(&quot;accountService&quot;); accountService.findAll(); } } 注解形式1.首先同样是导入坐标 2.提取jdbc.properties jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql:///test jdbc.username=root jdbc.password=123456 3.了解下Spring的一些基本注解吧 注解 说明 @Component 使用在类上用于实例化Bean @Controller 使用在web层类上用于实例化Bean @Service 使用在service层类上用于实例化Bean @Repository 使用在dao层类上用于实例化Bean @Autowired 使用在字段上用于根据类型依赖注入 @Qualifier 结合@Autowired一起使用用于根据名称进行依赖注入 @Resource 相当于@Autowired+@Qualifier，按照名称进行注入 @Value 注入普通属性 @Scope 标注Bean的作用范围 @PostConstruct 使用在方法上标注该方法是Bean的初始化方法 @PreDestroy 使用在方法上标注该方法是Bean的销毁方法 @Configuration 用于指定当前类是一个 Spring 配置类，当创建容器时会从该类上加载注解 @ComponentScan 用于指定 Spring 在初始化容器时要扫描的包。 作用和在 Spring 的 xml 配置文件中的 &lt;context:component-scan base-package=&quot;com.itheima&quot;/&gt;一样 @Bean 使用在方法上，标注将该方法的返回值存储到 Spring 容器中 @PropertySource 用于加载.properties 文件中的配置 @Import 用于导入其他配置类 使用注解进行开发时，需要在applicationContext.xml中配置组件扫描，作用是指定哪个包及其子包下的Bean需要进行扫描以便识别使用注解配置的类、字段和方法。 &lt;context:component-scan base-package=&quot;top.jigw&quot;&gt;&lt;/context:component-scan&gt; 4.AccountDaoImpl.java @Repository(&quot;accountDao&quot;) public class AccountDaoImpl implements AccountDao { private JdbcTemplate template; public void setTemplate(JdbcTemplate template) { this.template = template; } public void findAll(){ List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(&quot;select * from teacher&quot;); for (Map&lt;String, Object&gt; map : list) { for (String s : map.keySet()) { System.out.println(s+&quot;:&quot;+map.get(s)); } } } } 5.AccountServiceImpl.java @Service(&quot;accountService&quot;) public class AccountServiceImpl implements AccountService { private AccountDaoImpl accountDao; public void setAccountDao(AccountDaoImpl accountDao) { this.accountDao = accountDao; } @Override public void findAll() { ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); AccountDao accountDao = (AccountDao) applicationContext.getBean(&quot;accountDao&quot;); accountDao.findAll(); System.out.println(&quot;username:&quot;+username); } } 6.SpringConfiguration.java @Configuration @ComponentScan(&quot;top.jigw&quot;) @Import({DataSourceConfiguration.class}) public class SpringConfiguration { } 7.DataSourceConfiguration.java @PropertySource(&quot;classpath:jdbc.properties&quot;) public class DataSourceConfiguration { @Value(&quot;${jdbc.driver}&quot;) private String driver; @Value(&quot;${jdbc.url}&quot;) private String url; @Value(&quot;${jdbc.username}&quot;) private String username; @Value(&quot;${jdbc.password}&quot;) private String password; @Bean(name = &quot;dataSource&quot;) public DataSource getDataSource(){ DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(driver); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; } @Bean(name = &quot;template&quot;) public JdbcTemplate getTemplate(DataSource dataSource){ return new JdbcTemplate(dataSource); } } 集成Junit测试这里需要导入spring-test依赖包 Spring集成Junit步骤 ①导入spring集成Junit的坐标 ②使用@Runwith注解替换原来的运行期 ③使用@ContextConfiguration指定配置文件或配置类 ④使用@Autowired注入需要测试的对象 ⑤创建测试方法进行测试 SpringJunitTest.java @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = SpringConfiguration.class) public class SpringJunitTest { @Autowired private AccountService accountService; @Test public void testService(){ accountService.findAll(); } }]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>maven</tag>
        <tag>druid</tag>
        <tag>junit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[servlet域对象]]></title>
    <url>%2F2019%2F05%2F05%2Fservlet%E5%9F%9F%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[引言在学习servlet的过程中，数据共享是必须的操作。总的来说，我们要想共享数据往往是利用多个servlet或对象共同操作的一个对象，这类对象称之为作用域。 HttpServletRequest针对一次请求。使用该对象保存数据，一次请求(一个页面，如果是请求转发多个页面)内有效。 创建：客户端想服务器端发送一次请求 销毁：服务器响应后销毁 HttpServletSession针对一次会话。使用该对象保存数据，一次会话(多次请求)有效。 创建：请求未携带jsessionid时创建session对象，请求携带jsessionid但找不到对应的session时创建session对象。 销毁：1. 未正常关闭服务器 2. 手动调用了Session的invalidate方法 3. session过期了，有效时间默认为30分钟 HttpServletContext针对一个web应用。一个web应用只有一个ServletContext对象，该对象保存的数据对整个web应用都有效。我们可以把ServletContext与其他对象描绘成水和鱼类的关系。 创建：服务器启动的时候 销毁：服务器关闭的时候或者项目移除 三个作用域对象操作的APIapi都是一样的,完成存取和销毁的操作 存放数据：setAttribute(name,value) 获得数据：getAttribute(name) 删除数据：removeAttribute(name) 小结servlet为我们提供的三大域对象来帮助我们实现不同情况下的数据共享,若一个业务功能使用这三个域对象都可以实现,我们一般选用最小的域对象.作用域越小,生命周期越短,在一定程度上可以提供程序的执行效率]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>servlet</tag>
        <tag>request</tag>
        <tag>session</tag>
        <tag>ServletContext</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事务及隔离级别]]></title>
    <url>%2F2019%2F05%2F02%2F%E4%BA%8B%E5%8A%A1%E5%8F%8A%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%2F</url>
    <content type="text"><![CDATA[事务 简述事务是逻辑上的一组操作，要么都执行，要么都不执行。最简单的；例子如银行转账，双方一人账户增加多少钱，另一人账号就减少多少钱。 操作1. 开启事务： start transaction; 2. 回滚：rollback; 3. 提交：commit; 事务提交的方式： 1. 自动提交 MySQL的提交方式 2. 手动提交 Oracle的提交方式 修改事务提交的方式 查看事务的默认提交方式：SELECT @@autocommit; -- 1 代表自动提交 0 代表手动提交 修改默认提交方式： set @@autocommit = 0; 事务的四个特征 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败 持久性：当事务提交或回滚后，数据库会持久化的保存数据。 隔离性：多个事务之间。相互独立。 一致性：事务操作前后，数据总量不变 事务的隔离级别多个事务是相互隔离的、独立的，但多个事务处理同样一批数据时便会发生问题，这时就必须设置隔离级别来解决这些问题。 存在的问题 脏读(Dirty Read)：一个事务读取到另一个事务未提交的数据 不可重复读(虚读)(Unrepeatable Read)：同一个事务中，两次读取的数据不一样。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。 幻读(Phantom Read)：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。 有人也说还有第四种问题-丢失修改(Lost to modify)：指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=18，事务1的修改被丢失。 不可重复度和幻读区别：不可重复读的重点是修改，幻读的重点在于新增或者删除。 隔离级别 READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。 READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。 REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。 SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。 特点：安全等级越来越高，但效率越来越低。 数据库查询隔离级别： * select @@tx_isolation; 数据库设置隔离级别： * set global transaction isolation level 级别字符串; 补充在Github上的JavaGuide-master仓库中写到 由 SnailClimb 和 BugSpeak 共同完成。 这里需要注意的是：与 SQL 标准不同的地方在于InnoDB 存储引擎在 **REPEATABLE-READ（可重读）**事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ（可重读）** 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的**SERIALIZABLE(可串行化)**隔离级别。 因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是**READ-COMMITTED(读取提交内容):**，但是你要知道的是InnoDB 存储引擎默认使用 **REPEATABLE-READ（可重读）**并不会有任何性能损失。 InnoDB 存储引擎在 **分布式事务** 的情况下一般会用到**SERIALIZABLE(可串行化)**隔离级别。]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Oracle</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XML解析]]></title>
    <url>%2F2019%2F04%2F26%2FXML%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[解析 操作xml文档，将文档的数据读取到内存中。 解析方式DOM 将标记语言文档一次性加载进内存，在内存中形成一棵dom树 优点：操作方便，可以对文档进行CRUD的所有操作 缺点：占内存 SAX 逐行读取，基于事件驱动 优点：不占内存，相比DOM效率更高 缺点：只能读取，不能增删改 解析器常见解析器 1. JAXP：sun公司提供的解析器，支持dom和sax两种思想 2. DOM4J：一款非常优秀的解析器 3. Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 4. PULL：Android操作系统内置的解析器，sax方式的。 DOM4J本文中利用dom4j和xpath的支持进行解析，DOM4J中还提供了其他几种遍历节点的方法，例如枚举(Iterator)、递归、visitor模式等等。 范例 1. 导包 dom4j-1.6.1.jar jaxen-1.1-beta-6.jar 2. public class TestDemo01 { @Test public void method() throws DocumentException { //创建解析器 SAXReader saxReader = new SAXReader(); //解析xml Document document = saxReader.read(TestDemo01.class.getClassLoader().getResourceAsStream(&quot;student.xml&quot;)); //获取根标签 Element rootElement = document.getRootElement(); /*System.out.println(rootElement); //获取子标签 List elements = rootElement.elements(); //获取第一个 Object stu1 = elements.get(0); System.out.println(stu1); System.out.println(&quot;----------&quot;); //student个数 List student = rootElement.elements(&quot;student&quot;); int size = student.size(); System.out.println(size); System.out.println(&quot;----------&quot;); //获取第一个学号 Element stu = rootElement.element(&quot;student&quot;); String s1 = stu.attributeValue(&quot;number&quot;); System.out.println(s1); System.out.println(&quot;----------&quot;); //获取第一个年龄 Element age1 = stu.element(&quot;age&quot;); String text = age1.getText(); System.out.println(text); // 即每一级便签和下一级标签用element方法获取第一个 } } 3. 结合xpath Element element = (Element)rootElement.selectSingleNode(&quot;//student[@number=&apos;heima_0002&apos;]&quot;); System.out.println(element); //xpath语法可通过xpath API文档查询 可能出现的问题在idea中编程时，使用Schema约束会在写xml文件是自动出现 xmlns=”http://www.itcast.cn/xml&quot;，使用这样的xml编码方式再结合xpath进行解析时，会发生找不到结果的问题 &lt;students xmlns=&quot;http://www.itcast.cn/xml&quot;&gt; &lt;student number=&quot;heima_0001&quot;&gt; &lt;name&gt;zhangsan&lt;/name&gt; &lt;age&gt;24&lt;/age&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;/student&gt; &lt;/students&gt; 如获取 Element element = (Element)rootElement.selectSingleNode(&quot;//student[@number=&apos;heima_0002&apos;]&quot;); System.out.println(element); 结果为null Jsoup步骤： 1. 导入jar包 jsoup-1.11.2.jar JsoupXpath-0.3.2.jar 2. 获取Document对象 3. 获取对应的标签Element对象 4. 获取数据 代码： //2.1获取student.xml的path String path = JsoupDemo1.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath(); //2.2解析xml文档，加载文档进内存，获取dom树---&gt;Document Document document = Jsoup.parse(new File(path), &quot;utf-8&quot;); //3.获取元素对象 Element Elements elements = document.getElementsByTag(&quot;name&quot;); System.out.println(elements.size()); //3.1获取第一个name的Element对象 Element element = elements.get(0); //3.2获取数据 String name = element.text(); System.out.println(name); 对象的使用： 1. Jsoup：工具类，可以解析html或xml文档，返回Document * parse：解析html或xml文档，返回Document * parse​(File in, String charsetName)：解析xml或html文件的。 * parse​(String html)：解析xml或html字符串 * parse​(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象 2. Document：文档对象。代表内存中的dom树 * 获取Element对象 * getElementById​(String id)：根据id属性值获取唯一的element对象 * getElementsByTag​(String tagName)：根据标签名称获取元素对象集合 * getElementsByAttribute​(String key)：根据属性名称获取元素对象集合 * getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合 3. Elements：元素Element对象的集合。可以当做 ArrayList&lt;Element&gt;来使用 4. Element：元素对象 1. 获取子元素对象 * getElementById​(String id)：根据id属性值获取唯一的element对象 * getElementsByTag​(String tagName)：根据标签名称获取元素对象集合 * getElementsByAttribute​(String key)：根据属性名称获取元素对象集合 * getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合 2. 获取属性值 * String attr(String key)：根据属性名称获取属性值 3. 获取文本内容 * String text():获取文本内容 * String html():获取标签体的所有内容(包括字标签的字符串内容) 5. Node：节点对象 * 是Document和Element的父类 快捷查询方式： 1. selector:选择器 * 使用的方法：Elements select​(String cssQuery) * 语法：参考Selector类中定义的语法 2. XPath：XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言 * 使用Jsoup的Xpath需要额外导入jar包。 * 查询w3cshool参考手册，使用xpath的语法完成查询 * 代码： //1.获取student.xml的path String path = JsoupDemo6.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath(); //2.获取Document对象 Document document = Jsoup.parse(new File(path), &quot;utf-8&quot;); //3.根据document对象，创建JXDocument对象 JXDocument jxDocument = new JXDocument(document); //4.结合xpath语法查询 //4.1查询所有student标签 List&lt;JXNode&gt; jxNodes = jxDocument.selN(&quot;//student&quot;); for (JXNode jxNode : jxNodes) { System.out.println(jxNode); } System.out.println(&quot;--------------------&quot;); //4.2查询所有student标签下的name标签 List&lt;JXNode&gt; jxNodes2 = jxDocument.selN(&quot;//student/name&quot;); for (JXNode jxNode : jxNodes2) { System.out.println(jxNode); } System.out.println(&quot;--------------------&quot;); //4.3查询student标签下带有id属性的name标签 List&lt;JXNode&gt; jxNodes3 = jxDocument.selN(&quot;//student/name[@id]&quot;); for (JXNode jxNode : jxNodes3) { System.out.println(jxNode); } System.out.println(&quot;--------------------&quot;); //4.4查询student标签下带有id属性的name标签 并且id属性值为itcast List&lt;JXNode&gt; jxNodes4 = jxDocument.selN(&quot;//student/name[@id=&apos;itcast&apos;]&quot;); for (JXNode jxNode : jxNodes4) { System.out.println(jxNode); }]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>xml</tag>
        <tag>xpath</tag>
        <tag>DOM4J</tag>
        <tag>Jsoup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[更换电脑或重装系统时的博客配置]]></title>
    <url>%2F2019%2F03%2F30%2F%E5%8D%9A%E5%AE%A2%E9%87%8D%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[前言首先感谢网络上的大佬们，查阅了一些人的博客总算解决了这一难题。废话少说，下面是简单的教程。 准备 安装node.js 安装Git 备份你的本地博客目录的部分文件夹 node.js和Git的安装包参考 拷贝文件夹如下 _config.yml theme/ source/ scaffolds/ package.json .gitignore 配置你的Git桌面右键选择bash here,设置用户名称和邮件地址。 1 $ git config –global user.name “username” 2 $ git config –global user.email “username@xxxx.com“ 配置SSH Key输入 $ ssh-keygen -t rsa -C “你的邮件地址” 然后连续按三次回车，会生成id_rsa.pub文件，用记事本打开它，然后全部复制即可，待会要用。这个文件的地址：C:\Users\Administrator.ssh打开你的GitHub主页，打开设置-&gt;Deploy keys-&gt;Add deploy key.这里名称随便取，在下面粘贴内容保存即可。 我们回来测试下是否把SSH配置成功了。继续在bash里输入 $ ssh -T git@github.com 如果提示 Are you sure you want to continue connecting (yes/no)? ，输入yes，然后会看到 successfully authenticated,but github…..看到这个意味着已成功！ 正式工作接下来时hexo和一些组件的安装，恭喜了很快了。 安装hexo我们打开cmd命令行，输入 npm install -g hexo 这里可能会很慢，所以推荐使用淘宝镜像。 npm install -g cnpm –registry=https://registry.npm.taobao.org 验证是否安装成功使用： cnpm -v 安装了淘宝镜像后，都使用cnpm指令： cnpm install -g hexo // 安装 hexo 验证Hexo是否安装成功使用： hexo -v 安装一些组件 npm install hexo-deployer-git –save // 文章部署到 git 的模块（下面为选择安装） npm install hexo-generator-feed –save // 建立 RSS 订阅 npm install hexo-generator-sitemap –save // 建立站点地图 部署到Github输入指令 hexo generate hexo deploy 没有报错就OK了。这里讲讲hexo的一些快捷命令 hexo g == hexo generate hexo d == hexo deploy hexo s == hexo server hexo n == hexo new 测试尝试部署文章并使用以下指令更新部署 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 成功部署，恭喜你！博客重配置成功！ 如果觉得有用，不如给个Star Or Follow，感谢。]]></content>
      <categories>
        <category>HexoAndBlog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2019%2F03%2F26%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[理解设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 何为单例模式单例模式(Singleton)，又称单态模式或者单件模式。即保证一个类仅有一个实例，并提供一个访问它的全局访问点。目的是即控制特定的类只产生一个对象，也允许在一定情况下灵活的改变对象的个数。 如何实现先看一段代码 public class Thing { private Thing(){ } private static Thing instance = new Thing(); //这段代码保证了Thread safe public static Thing getInstance(){ return instance; ｝ ｝ 测试类 public class TestDemo { public static void main(String[] args) { Thing t1 = Thing.getInstance(); Thing t2 = Thing.getInstance(); System.out.println(t1); System.out.println(t2); } } 输出t1和t2的结果是一致的。可以发现，我们将构造方法私有化了，这使得外面的类无法通过引用来创建对象；同时为了保证类的可用性，就必须提供一个自己的对象以及访问这个对象的静态方法。因此，我们应该明白：单例模式只有一个角色，而客户通过调用类的方法来创建对象。 还有什么在上面的Thing类中我们“迫不及待”的创建了对象，但如果这个对象我们很长时间都没有使用就浪费了内存空间，因此称之为饿汉式。存在另一种写法，即懒汉式。看这段代码 private static Thing instance; public static Thing getInstance(){ if (instance==null){ instance = new Thing(); } return instance; } 很明显，当程序真正需要这个对象的时候我们才开始创建。但是这在多线程情况下是有问题的，为了防止多线程环境中产生多个实例，我们做出改进，使用同步处理。 private static Thing instance; public static Thing getInstance(){ //如果是对象还没创建的时候使用同步，如果对象已经创建完了，就不要同步了 ，这样效率就可以提高 if (instance==null){ synchronized (Thing.class){ if (instance==null){ //说明对象还没创建，所以里面使用了同步s instance = new Thing(); } } } return instance; } 这里我们使用的是同步代码块，为什么不要同步方法呢？ private static Thing instance; public synchronized static Thing getInstance(){ if (instance==null){ instance = new Thing(); } return instance; } 通过使用同步方法，迫使每个线程在进入这个方法前要等候别的进程离开该方法。但同步会降低性能，并且这里只有第一次执行该方法时才会正在需要同步。之后每一次调用这个方法，同步都是浪费的。 存在的问题在学习单例模式时，通过这方面的书籍了解到以下问题 如果觉得有用，不如给个Star Or Follow，感谢。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>interview</tag>
        <tag>designPattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于我的考研]]></title>
    <url>%2F2019%2F02%2F20%2F190405%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>mood</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何将本地项目部署到Github]]></title>
    <url>%2F2019%2F02%2F05%2F%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E5%88%B0github%2F</url>
    <content type="text"><![CDATA[前言众所周知，GitHub是一个面向开源及私有软件项目的托管平台，那我们该如何将本地项目导入到Github上呢，这里，我写一个简单的教程，希望对你有所帮助。 准备确定你的Git安装了，如果需要点击此处 开始首先在Github上新建一个repository，命名随意（以我为例，新建了一个Demo），勾选如图，create。 然后，进入你的repository,打开settings，可以看到Github Pages的设置，在source中选择master branch。 最后，选择完会刷新页面，在去看Gith Pages时，会有显示一个网址，这就是你之后访问你项目页面的网址。 快了在一个盘里右键点击git bash here，打开bash命令行。如图，输入命令在D盘创建了文件夹Demo，第三个命令是克隆地址，格式为 https://github.com/用户名/项目名.git 这时候你会发现你的D盘会多个Demo文件夹，打开它，进入根目录。 将自己的项目文件粘贴到这个根目录中。 执行如下命令， 这里面注意，第一次操作需要你输入相关账号和密码，到时根据提示输入即可 完成利用那个网址测试即可。 如果觉得有用，不如给个starorfollow，感谢。]]></content>
      <categories>
        <category>HexoAndBlog</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XML简介与约束]]></title>
    <url>%2F2018%2F12%2F22%2FXML%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[简介 XML是可扩展标记语言（Extensible Markup Language），可扩展即标签都是自定义的。 功能：存储数据 1. 配置文件 2. 在网络中传输 与HTML的区别 1. xml标签都是自定义的，html标签是预定义。 2. xml的语法严格（严格区分大小写），html语法松散 3. xml是存储数据的，html是展示数据 各个平台之间的数据传输类型，但现在已经被JSON替换了。XML可以存储简单、小量的数据。 基本语法 写法注意： 属性值必须使用引号(单双都可)引起来 标签名称区分大小写 示例 &lt;?xml version=&apos;1.0&apos; ?&gt; &lt;users&gt; &lt;user id=&apos;1&apos;&gt; &lt;name&gt;zhangsan&lt;/name&gt; &lt;age&gt;23&lt;/age&gt; &lt;gender&gt;男&lt;/gender&gt; &lt;/user&gt; &lt;user id=&apos;2&apos;&gt; &lt;name&gt;lisi&lt;/name&gt; &lt;age&gt;25&lt;/age&gt; &lt;gender&gt;男&lt;/gender&gt; &lt;/user&gt; &lt;/users&gt; 组成部分1. 文档声明 1. 格式：&lt;?xml 属性列表 ?&gt; 2. 属性列表： * version：版本号，必须的属性 * encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1 * standalone：是否独立 * 取值： * yes：不依赖其他文件 * no：依赖其他文件 2. 指令(了解)：结合css的 * &lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;a.css&quot; ?&gt; 3. 标签：标签名称自定义的 * 规则： * 名称可以包含字母、数字以及其他的字符 * 名称不能以数字或者标点符号开始 * 名称不能以字母 xml（或者 XML、Xml 等等）开始 * 名称不能包含空格 4. 属性： id属性值唯一 5. 文本： * CDATA区：在该区域中的数据会被原样展示 * 格式： &lt;![CDATA[ 数据 ]]&gt; 约束约束为规定XML文档的编写规则。 第一种约束 DTD 外部dtd：将约束的规则定义在外部的dtd文件中 * 本地：&lt;!DOCTYPE 根标签名 SYSTEM &quot;dtd文件的位置&quot;&gt; * 网络：&lt;!DOCTYPE 根标签名 PUBLIC &quot;dtd文件名字&quot; &quot;dtd文件的位置URL&quot;&gt; 内部dtd：写在内部 外部范例 //student.dtd文件 &lt;!ELEMENT students (student+) &gt; &lt;!ELEMENT student (name,age,sex)&gt; &lt;!ELEMENT name (#PCDATA)&gt; &lt;!ELEMENT age (#PCDATA)&gt; &lt;!ELEMENT sex (#PCDATA)&gt; &lt;!ATTLIST student number ID #REQUIRED&gt; //student.xml文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE students SYSTEM &quot;student.dtd&quot;&gt; &lt;students&gt; &lt;student number=&quot;s001&quot;&gt; &lt;name&gt;zhangsan&lt;/name&gt; &lt;age&gt;abc&lt;/age&gt; &lt;sex&gt;hehe&lt;/sex&gt; &lt;/student&gt; &lt;student number=&quot;s002&quot;&gt; &lt;name&gt;lisi&lt;/name&gt; &lt;age&gt;24&lt;/age&gt; &lt;sex&gt;female&lt;/sex&gt; &lt;/student&gt; &lt;/students&gt; 第二种约束 Schema 引入 1. 填写xml文档的根元素 2. 引入xsi前缀. xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 3. 引入xsd文件命名空间. xsi:schemaLocation=&quot;http://www.itcast.cn/xml student.xsd&quot; 4. 为每一个xsd约束声明一个前缀,作为标识 xmlns=&quot;http://www.itcast.cn/xml&quot; &lt;students xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://www.itcast.cn/xml&quot; xsi:schemaLocation=&quot;http://www.itcast.cn/xml student.xsd&quot;&gt; 范例 student.xsd &lt;?xml version=&quot;1.0&quot; ?&gt; &lt;xsd:schema xmlns=&quot;http://www.itcast.cn/xml&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; targetNamespace=&quot;http://www.itcast.cn/xml&quot; elementFormDefault=&quot;qualified&quot;&gt; &lt;xsd:element name=&quot;students&quot; type=&quot;studentsType&quot;/&gt; &lt;xsd:complexType name=&quot;studentsType&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element name=&quot;student&quot; type=&quot;studentType&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:complexType&gt; &lt;xsd:complexType name=&quot;studentType&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element name=&quot;name&quot; type=&quot;xsd:string&quot;/&gt; &lt;xsd:element name=&quot;age&quot; type=&quot;ageType&quot; /&gt; &lt;xsd:element name=&quot;sex&quot; type=&quot;sexType&quot; /&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;number&quot; type=&quot;numberType&quot; use=&quot;required&quot;/&gt; &lt;/xsd:complexType&gt; &lt;xsd:simpleType name=&quot;sexType&quot;&gt; &lt;xsd:restriction base=&quot;xsd:string&quot;&gt; &lt;xsd:enumeration value=&quot;male&quot;/&gt; &lt;xsd:enumeration value=&quot;female&quot;/&gt; &lt;/xsd:restriction&gt; &lt;/xsd:simpleType&gt; &lt;xsd:simpleType name=&quot;ageType&quot;&gt; &lt;xsd:restriction base=&quot;xsd:integer&quot;&gt; &lt;xsd:minInclusive value=&quot;0&quot;/&gt; &lt;xsd:maxInclusive value=&quot;256&quot;/&gt; &lt;/xsd:restriction&gt; &lt;/xsd:simpleType&gt; &lt;xsd:simpleType name=&quot;numberType&quot;&gt; &lt;xsd:restriction base=&quot;xsd:string&quot;&gt; &lt;xsd:pattern value=&quot;heima_\d{4}&quot;/&gt; &lt;/xsd:restriction&gt; &lt;/xsd:simpleType&gt; &lt;/xsd:schema&gt; student.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;students xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://www.itcast.cn/xml&quot; xsi:schemaLocation=&quot;http://www.itcast.cn/xml student.xsd&quot; &gt; &lt;student number=&quot;heima_0001&quot;&gt; &lt;name&gt;tom&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;/student&gt; &lt;/students&gt;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>xml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat问题和项目部署]]></title>
    <url>%2F2018%2F10%2F09%2Ftomcat%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Tomcat可能出现的问题 1. 黑窗口一闪而过： * 原因： 没有正确配置JAVA_HOME环境变量 * 解决方案：正确配置JAVA_HOME环境变量，并在path中添加%JAVA_HOME%\bin; 2. 启动报错： 1. 暴力修改：找到占用的端口号，并且找到对应的进程，杀死该进程 * 命令行输入netstat -ano，查询到端口豪对应进程的PID 2. 温柔修改：修改自身的端口号 * conf/server.xml * &lt;Connector port=&quot;8888&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8445&quot; /&gt; * 一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。 * 好处：在访问时，就不用输入端口号 在Tomcat中部署项目的方式 1. 直接将项目放到webapps目录下即可。 * /WebProject：项目的访问路径--&gt;虚拟目录 * 简化部署：将项目打成一个war包，再将war包放置到webapps目录下。 * war包会自动解压缩 2. 配置conf/server.xml文件 在&lt;Host&gt;标签体中配置 &lt;Context docBase=&quot;D:\WebProject&quot; path=&quot;/demo&quot; /&gt; * docBase:项目存放的路径 * path：虚拟目录 3. 在conf\Catalina\localhost创建任意名称的xml文件。在文件中编写 &lt;Context docBase=&quot;D:\WebProject&quot; /&gt; * 虚拟目录：xml文件的名称 4. 在IDE中]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse的maven插件安装]]></title>
    <url>%2F2018%2F09%2F07%2Feclipse%E6%8F%92%E4%BB%B6maven%2F</url>
    <content type="text"><![CDATA[以eclipse kepler为例，官网下载地址：http://www.eclipse.org/downloads/packages/release/Kepler/SR2 1.打开eclipse，help–install new software… 2.workwith里输入：http://download.eclipse.org/releases/kepler，输入完会有提示地址出现，点击回车静待... 3.在filter框中输入maven便能定位要安装的插件 4.选择“Collaboration”-“m2e - Maven Integration for Eclipse”，并点击next按钮进行安装 5.安装完成重启eclipse即可 6.配置你的maven 如果觉得有用，不如给个Star Or Follow，感谢。]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多态的一道面试题]]></title>
    <url>%2F2018%2F08%2F11%2F%E5%A4%9A%E6%80%81%E7%9A%84%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[多态类A： class A { public String show(D obj){ return (&quot;A and D&quot;); } public String show(A obj){ return (&quot;A and A&quot;); } } 类B： class B extends A{ public String show(B obj){ return (&quot;B and B&quot;); } public String show(A obj){ return (&quot;B and A&quot;); } } 类C： class C extends B{} 类D： class D extends B{} 测试类： class DynamicTest{ public static void main(String[] args){ A a1 = new A(); A a2 = new B(); B b = new B(); C c = new C(); D d = new D(); System.out.println(a1.show(b)); System.out.println(a1.show(c)); System.out.println(a1.show(d)); System.out.println(a2.show(b)); System.out.println(a2.show(c)); System.out.println(a2.show(d)); System.out.println(b.show(b)); System.out.println(b.show(c)); System.out.println(b.show(d)); } } 答案： System.out.println(a1.show(b)); AA System.out.println(a1.show(c)); AA System.out.println(a1.show(d)); AD System.out.println(a2.show(b)); BA 编译看左边，看右边可有重写 System.out.println(a2.show(c)); BA 同样，看可有重写！ System.out.println(a2.show(d)); AD 编译看左边，但没有重写 System.out.println(b.show(b)); BB System.out.println(b.show(c)); BB 这里父类和爷爷类都可以，取最近的 System.out.println(b.show(d)); AD B是A的子类 ，会把A的方法都继承 如果觉得有用，不如给个Star Or Follow，感谢。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>interview</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构造、静态代码块面试题]]></title>
    <url>%2F2018%2F06%2F05%2F%E6%9E%84%E9%80%A0%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%2F</url>
    <content type="text"><![CDATA[复习构造代码块的执行时机：每次我们调用构造方法的时候都会先执行构造代码块中的代码，然后才去执行对应的构造方法中的代码。 静态代码块的执行时机：静态代码块其实就是在类加载的时候执行，一个类只会加载一次，所以静态代码块也最多只会执行一次。 public class Test01 { { System.out.println(&quot;Test01的构造代码块&quot;); } static { System.out.println(&quot;Test01的静态代码块&quot;); } public Test01() { System.out.println(&quot;Test01的构造方法&quot;); } public static void main(String[] args) { Student stu = new Student(); Student stu2 = new Student(); } } class Student { { System.out.println(&quot;Student的构造代码块&quot;); } static { System.out.println(&quot;Student的静态代码块&quot;); } public Student() { System.out.println(&quot;Student的构造方法&quot;); } } 答案：Test01的静态代码块 Student的静态代码块 Student的构造代码块Student的构造方法 Student的构造代码块 Student的构造方法 如果觉得有用，不如给个Star Or Follow，感谢。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>interview</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡、插入、选择排序]]></title>
    <url>%2F2018%2F03%2F03%2F%E6%8E%92%E5%BA%8F1%2F</url>
    <content type="text"><![CDATA[问题的引入从键盘输入10个整数并按从大到小的顺序排列，输出结果冒泡排序基本思想：比较所有相邻的两个元素，如果第一个数比第二个数大就交换它们两个。最后的数字应该最大得到升序排列。 package top.jgw; import java.util.Arrays; import java.util.Scanner; public class BubbleSort { public static void main(String[] args) { Scanner ra = new Scanner(System.in); System.out.print(&quot;请输入10个数：&quot;); int[] arr = new int[10]; for(int a=0;a&lt;10;a++){ arr[a] = ra.nextInt(); } System.out.println(&quot;排序前的arr：&quot;+Arrays.toString(arr)); for(int i=arr.length-1;i&gt;0;i--){ for(int j=1;j&lt;=i;j++){ if(arr[j-1]&gt;arr[j]){ int temp = arr[j-1]; arr[j-1] = arr[j]; arr[j] = temp; } } } System.out.println(&quot;排序后的arr ：&quot;+Arrays.toString(arr)); } } 结论：冒泡排序是一种稳定的排序方法。 若文件初状为正序，则一趟起泡就可完成排序，排序码的比较次数为n-1，且没有记录移动，时间复杂度是O(n) 若文件初态为逆序，则需要n-1趟起泡，每趟进行n-i次排序码的比较，且每次比较都移动三次，比较和移动次数均达到最大值∶O(n2) 起泡排序平均时间复杂度为O(n2) 插入排序基本思想：每一步将一个待排序的记录，按其顺序码大小插入到前面已经排序的序列的合适位置（从后向前找到合适位置后），直到全部插入排序完为止。 package top.jgw; import java.util.Arrays; import java.util.Scanner; public class InsertionSort { public static void main(String[] args){ int i,j; int temp=0; Scanner ra=new Scanner(System.in); System.out.print(&quot;请输入10个数：&quot;); int arr[]=new int[10]; for(int a=0;a&lt;10;a++){ arr[a]=ra.nextInt(); } System.out.println(&quot;排序前的arr: &quot;+Arrays.toString(arr)); for(i=1;i&lt;arr.length;i++){ temp=arr[i]; for(j=i-1;j&gt;=0 &amp;&amp; temp&lt;arr[j];j--){ arr[j+1]=arr[j]; } arr[j+1]=temp; } System.out.println(&quot;排序后的arr：&quot;+Arrays.toString(arr)); } } 结论：直接插入排序也是稳定的排序。文件初态不同时，直接插入排序所耗费的时间有很大差异。若文件初态为正序，则每个待插入的记录只需要比较一次就能够找到合适的位置插入，故算法的时间复杂度为O(n)，这时最好的情况。若初态为反序，则第i个待插入记录需要比较i+1次才能找到合适位置插入，故时间复杂度为O(n2)，这时最坏的情况。 选择排序基本思想：每一次排序都从待排序序列中选择一个最小元素放到已排好的序列的末端，重复此步骤可得到升序序列。 package top.jgw; import java.util.Arrays; import java.util.Scanner; public class SelectionSort { public static void main(String[] args){ Scanner ra=new Scanner(System.in); System.out.print(&quot;请输入10个数: &quot;); int arr[]=new int[10]; for(int a=0;a&lt;10;a++){ arr[a]=ra.nextInt(); } System.out.println(&quot;排序前的arr: &quot;+Arrays.toString(arr)); int temp=0; for(int i=0;i&lt;arr.length-1;i++){ for(int j=i+1;j&lt;arr.length;j++){ if(arr[i]&gt;arr[j]){ temp=arr[i]; arr[i]=arr[j]; arr[j]=temp; } } } System.out.println(&quot;排序后的arr: &quot;+Arrays.toString(arr)); } } 结论：简单选择排序是不稳定的排序，时间复杂度：T(n)=O(n2)。 日后补充… 如果觉得有用，不如给个Star Or Follow，感谢。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo＋next主题搭建GitHub blog干货教程]]></title>
    <url>%2F2018%2F01%2F10%2Fhexo%2F</url>
    <content type="text"><![CDATA[前言本人开始并非使用next主题，这个大家可以去hexo官网themes处挑选自己喜欢的。注意：点击主题预览图可以去预览下，点击主题名就可以去GitHub页面copy了。但个人觉得next主题更好，bug少，拓展性强。好了，废话少说，进入正题。 准备工作 注册github账号 安装node.js 链接：https://pan.baidu.com/s/1mji9SmO 密码：fjw1 安装git 链接：https://pan.baidu.com/s/1dGUlqEH 密码：q9ws我的电脑是Windows10，其他你根据我提供的百度云链接下载即可。安装git时全打勾。 创建仓库新建一个 你的用户名.github.io的仓库，比如说你的GitHub用户名是abc,那么你新建仓库名叫abc.github.io,你的博客搭建好之后访问的网站也就是 https://abc.github.io了。 那怎么删除仓库呢？？？打开settings 创建博客根目录在一个磁盘里创建一个文件夹，比如我，在D盘创建了一个blog文件夹。 正式工作配置SSH Key桌面右键打开git bash here,输入 $ cd ~/. ssh // 检查本机已存在的 ssh 密钥 再接着输入 ssh-keygen -t rsa -C “你的邮件地址” 然后连续按三次回车，会生成id_rsa.pub文件，用记事本打开它，然后全部复制即可，待会要用。这个文件的地址：C:\Users\Administrator.ssh打开你的GitHub主页，打开设置-&gt;Deploy keys-&gt;Add deploy key.这里名称随便取，在下面粘贴内容保存即可，有需要打勾就打勾。 我们回来测试下是否把SSH配置成功了。继续在bash里输入 $ ssh -T git@github.com 如果提示 Are you sure you want to continue connecting (yes/no)? ，输入yes，然后会看到 successfully authenticated,but github…..看到这个意味着已成功！ 配置信息 $ git config –global user.name “xxx”// 你的github用户名，比如上面的abc$ git config –global user.email “xxx@qq.com“// 填写你的github注册邮箱 使用hexo安装hexo我们打开cmd命令行，输入 npm install -g hexo 这里可能会很慢，所以推荐使用淘宝镜像。 安装：npm install -g cnpm --registry=https://registry.npm.taobao.org 验证是否安装成功使用：cnpm -v这里使用使用： cnpm install -g hexo安装hexo 验证Hexo是否安装成功使用：hexo -v 初始化hexo打开我们之前创建的文件夹，比如我的blog，右击鼠标，打开git bash here,输入 $ hexo init 我们的文件夹会自动下载一些文件到这个blog目录里。 继续输入 $ hexo g$ hexo s hexo s是指启动服务，成功打开后会有提示，登录localhost:4000即可看到初始页面，到这里你的blog就基本搭建好了。 新建文章在bash里输入 $ hexo new post “文章名” 然后去blog/source/_posts就可以看到 上传到GitHub配置_config.yml中的deploy部分，注意这里的_config.yml文件是blog根目录，并非themes里的同名文件。配置如下(xxx为你的GitHub名) deploy: type: git repository: git@github.com:xxx/xxx.github.io.git branch: master 再次注意：关于_config.yml文件的配置，冒号后一定要加个空格，否则就无法部署了。 一切完成后在bash中继续输入 npm install hexo-deployer-git –save #这里是安装插件，不然无法deploy 然后输入以下就可以了 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 成功后会提示：Deploy done：git 证明成功啦。这是打开你的xxx.github.io就可以看到网页啦！ 主题设置打开next使用文档有详细的教程。主题教程以及拓展： 绑定个性域名申请域名在阿里云或腾讯云申请域名。我是在阿里云申请的，实名认证很快，推荐。 解析域名按我的内容来即可。 部署域名在blog根目录的source文件夹中新建无后缀文件 CNAME。里面内容只写上你的域名即可，注意不需要www按之前的顺序deploy即可 如果觉得有用，不如给个Star Or Follow，感谢。]]></content>
      <categories>
        <category>HexoAndBlog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[出发永远是美好的一件事]]></title>
    <url>%2F2018%2F01%2F07%2F%E5%87%BA%E5%8F%91%2F</url>
    <content type="text"><![CDATA[去做就是啦。 总结了一七再去展望一八，哈哈我是真想做个技术流人才然后……忙着结束手头上的事情，项目等等，想着去全身心投入到学习中，这是促进我去搭建自己的独立博客的初衷，去学习，去整理，去分享。大学也浪了大半了，两次六级考试都几乎零准备，湖泊你说咋写来着？ 要说新年计划的话，最近打算好好总结Java的知识，以及对基本框架，数据结构与算法的学习，对博客的维护与优化，还有考研的准备！ 新年快乐！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>mood</tag>
      </tags>
  </entry>
</search>
